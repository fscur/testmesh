#pragma once

#include "geometry.h"
#include "lineMesh.h"
#include "ray.h"

#include <glm\glm.hpp>
#include <glm\gtc\constants.hpp>
#include <glm\gtc\type_ptr.hpp>

#include <windows.h>
#include <parasolid\frustrum_ifails.h>
#include <parasolid\parasolid_kernel.h>

#include <cstdio>
#include <string>
#include <vector>
#include <map>

#define max_namelen 255 // maximum length of a full pathname
#define max_open_files 32
#define dir_separator_s "\\"
#define end_of_string_s "\0"
#define null_strid (-1)
#define max_header_line (max_namelen+32) // for long FILE=name in the header
#define read_access 1

// File Guise Tokens
#define FFCROL (1) // rollback file
#define FFCSNP (2) // snapshot file
#define FFCJNL (3) // journal file
#define FFCXMT (4) // transmit file (generated by the C-kernel)
#define FFCXMO (5) // transmit file (generated by the old Fortran kernel)
#define FFCSCH (6) // schema file
#define FFCLNC (7) // licence file
#define FFCXMP (8) // transmit file (partition)
#define FFCXMD (9) // transmit file (deltas)
#define FFCDBG (10) // debug report file
#define FFCXMM (11) // transmit file (meshes)

// File Format Tokens
#define FFBNRY (1) // binary
#define FFTEXT (2) // text
#define FFAPPL (3) // applio
#define FFXML  (4) // xml

// File Open Mode Tokens
#define FFSKHD (1) // skip header after opening file for read (usual)
#define FFLVHD (2) // leave header after opening file for read (fru tests)

#define BUFFER_SIZE 1000

typedef struct file_s *file_p;

static int file_count = 0;
static file_p open_files = NULL;
static int stream_id[max_open_files];
static char *input_output_buffer = NULL;
static size_t input_output_buflen = 0;
static char g_trailer_start[max_header_line] = "**END_OF_HEADER";
static char g_preamble_1[max_header_line] = end_of_string_s;
static char g_fopen_mode_read_text[] = "r";
static char g_fopen_mode_read_binary[] = "rb";

typedef struct file_s
{
    file_p next;
    file_p prev;
    int    strid;
    int    guise;
    int    format;
    int    access;
    char   name[max_namelen + 1];
    char   key[max_namelen + 1];
    FILE  *stream;
} file_t;

extern void StartFileFrustrum(int *);
extern void AbortFrustrum(int *);
extern void StopFileFrustrum(int *);
extern void OpenWriteFrustrumFile(const int *, const int *, const char *, const int *, const char *, const int *, int *, int *);
extern void CloseFrustrumFile(const int *, const int *, const int *, int *);
extern void OpenReadFrustrumFile(const int*, const int*, const char*, const int*, const int*, int*, int*);
extern void ReadFromFrustrumFile(const int *, const int *, const int *, char *, int *, int *);
extern void WriteToFrustrumFile(const int *, const int *, const int *, const char *, int *);

void StartFrustrum(int * ifail)
{
    *ifail = FR_no_errors;
    StartFileFrustrum(ifail);
}

void StopFrustrum(int * ifail)
{
    *ifail = FR_no_errors;
    StopFileFrustrum(ifail);
}

void GetMemory(int* nBytes, char** memory, int* ifail)
{
    *memory = new char[*nBytes];
    *ifail = (*memory) ? FR_no_errors : FR_memory_full;
}

void ReturnMemory(int* nBytes, char** memory, int* ifail)
{
    delete[] * memory;
    *ifail = FR_no_errors;
}

struct collision
{
    int parasolidId;
    glm::dvec3 worldPos;
    glm::dvec3 worldNormal;
};

class parasolid
{
private:
    std::vector<PK_BODY_t> _bodies;
    std::map<PK_BODY_t, geometry*> _bodyGeometries;
    PK_BODY_t _offsetBody;
    PK_FACE_t _offsetFace;
    PK_VECTOR1_t _offsetDir;
    PK_FACE_t _polygonFace;
    std::vector<PK_VECTOR_t> _polygonPoints;
    PK_BODY_t _tempBody;
    lineMesh* _polygonMesh = nullptr;
    float lastT2;
    geometry* _geometry;

private:

    void findGeometryData(PK_BODY_t body, std::vector<vertex> &vertices, std::vector<uint> &indices)
    {
        PK_TOPOL_facet_2_o_t opt;
        PK_TOPOL_facet_2_o_m(opt);
        opt.choice.point_vec = PK_LOGICAL_true;
        opt.choice.normal_vec = PK_LOGICAL_true;
        opt.choice.param_uv = PK_LOGICAL_true;
        opt.choice.fin_data = PK_LOGICAL_true;
        opt.choice.strip_zigzag = PK_LOGICAL_true;
        opt.choice.facet_fin = PK_LOGICAL_true;
        opt.choice.data_point_idx = PK_LOGICAL_true;
        opt.choice.data_normal_idx = PK_LOGICAL_true;
        opt.choice.data_param_idx = PK_LOGICAL_true;
        PK_TOPOL_facet_2_r_t ret;
        PK_TOPOL_facet_2(1, &body, nullptr, &opt, &ret);

        auto findTable = [&](PK_TOPOL_fctab_t type)
        {
            for (int i = 0; i < ret.number_of_tables; i++)
            {
                if (ret.tables[i].fctab == type)
                    return ret.tables[i].table;
            }
        };

        auto fin_data_table = findTable(PK_TOPOL_fctab_fin_data_c);
        auto strip_zigzag_table = findTable(PK_TOPOL_fctab_strip_zigzag_c);
        auto point_vec_table = findTable(PK_TOPOL_fctab_point_vec_c);
        auto normal_vec_table = findTable(PK_TOPOL_fctab_normal_vec_c);
        auto param_uv_table = findTable(PK_TOPOL_fctab_param_uv_c);
        auto data_point_table = findTable(PK_TOPOL_fctab_data_point_c);
        auto data_normal_table = findTable(PK_TOPOL_fctab_data_normal_c);
        auto data_param_table = findTable(PK_TOPOL_fctab_data_param_c);

        auto strip_zigzag = strip_zigzag_table.strip_zigzag;
        auto strip_zigzag_data = strip_zigzag->data;

        vertices = std::vector<vertex>();
        indices = std::vector<uint>();
        auto addVertex = [&](int i)
        {
            auto finIndex = strip_zigzag_data[i].fin;
            auto dataIndex = fin_data_table.fin_data->data[finIndex];

            auto pointIndex = data_point_table.data_point_idx->point[dataIndex];
            auto point = point_vec_table.point_vec->vec[pointIndex];
            auto pos = glm::vec3(point.coord[0], point.coord[2], point.coord[1]);

            auto normalIndex = data_normal_table.data_normal_idx->normal[dataIndex];
            auto norm = normal_vec_table.normal_vec->vec[normalIndex];
            auto normal = glm::vec3(norm.coord[0], norm.coord[2], norm.coord[1]);

            auto paramIndex = data_param_table.data_param_idx->param[dataIndex];
            auto uv = param_uv_table.param_uv->data[paramIndex];
            auto texCoord = glm::vec2(uv.u, uv.v);

            vertices.push_back(vertex(pos, texCoord, normal));
        };

        auto i = 0;
        auto parity = false;
        while (i < strip_zigzag->length)
        {
            auto stripIndex = strip_zigzag_data[i].strip;
            auto oldest = i; addVertex(i++);
            auto older = i; addVertex(i++);
            parity = false;

            while (stripIndex == strip_zigzag_data[i].strip && i < strip_zigzag->length)
            {
                auto current = i; addVertex(i++);
                indices.push_back(current);
                indices.push_back(older);
                indices.push_back(oldest);

                if (parity = !parity)
                    oldest = current;
                else
                    older = current;
            }
        }
    }

    void updateGeometry(PK_BODY_t body, geometry* geometry)
    {
        std::vector<vertex> vertices;
        std::vector<uint> indices;
        findGeometryData(body, vertices, indices);
        geometry->change(vertices, indices);
    }

    lineMesh* createLineMesh(PK_BODY_t wireBody)
    {
        std::vector<glm::vec3> positions;
        std::vector<uint> indices;

        int n;
        PK_EDGE_t* edges;
        PK_BODY_ask_edges(wireBody, &n, &edges);
        for (auto i = 0; i < n; i++)
        {
            auto edge = edges[i];

            PK_VERTEX_t points[2];
            PK_EDGE_ask_vertices(edge, points);
            PK_POINT_t startPoint, endPoint;
            PK_VERTEX_ask_point(points[0], &startPoint);
            PK_VERTEX_ask_point(points[1], &endPoint);
            PK_POINT_sf_s startPointSF, endPointSF; // PORQUE DIABOS TANTA MÃO SÓ PRA PEGAR 2 PONTOS?!?!?!?!?!?!!?!1!?1
            PK_POINT_ask(startPoint, &startPointSF);
            PK_POINT_ask(endPoint, &endPointSF);
            auto startPos = startPointSF.position.coord;
            auto endPos = endPointSF.position.coord;

            auto start = glm::vec3(startPos[0], startPos[2], startPos[1]); // FINALMENTE!
            auto end = glm::vec3(endPos[0], endPos[2], endPos[1]);

            positions.push_back(start);
            positions.push_back(end);
            indices.push_back(i * 2);
            indices.push_back(i * 2 + 1);
        }

        return lineMesh::create("tudo bom, e tu?", positions, indices);
    }

    void displayModelStructure(PK_BODY_t body)
    {
        std::string resultList;
        std::string result;
        int num = 0, n_solid_regions = 0;
        PK_ENTITY_t *entity;
        PK_LOGICAL_t is_solid;
        PK_SHELL_type_t shell_type;
        PK_EDGE_ask_type_t edge_types;
        PK_VERTEX_type_t vertex_types;
        PK_LOOP_type_t loop_types;
        int n_acorn = 0, n_wire = 0, n_wire_free = 0, n_mixed = 0;
        int n_general = 0, n_laminar = 0, n_wireframe = 0, n_normal = 0;
        int n_isolated = 0, n_spur = 0, n_wire_vertex = 0, n_norm = 0;
        int n_vertex = 0, n_wireframe_vertex = 0, n_inner = 0, n_outer = 0,
            n_winding = 0, n_inner_sing = 0, n_likely_inner = 0, n_likely_outer = 0, n_unclear = 0;

        result = "The body consists of:\r\n\r\n";
        resultList.append(result);

        //////////////////**regions**//////////////////////////////////////
        PK_BODY_ask_regions(body, &num, &entity);
        char pcRegion[BUFFER_SIZE];
        sprintf_s(pcRegion, BUFFER_SIZE, "%d region(s):\r\n", num);
        result.assign(pcRegion);
        resultList.append(result);
        for (int i = 1; i < num; i++)
        {
            PK_REGION_is_solid(entity[i], &is_solid);
            if (is_solid)
                n_solid_regions++;
        }
        char pcInfiniteVoid[BUFFER_SIZE];
        sprintf_s(pcInfiniteVoid, BUFFER_SIZE, "\t 1 infinite void, %d solid, %d finite void\r\n", n_solid_regions, num - 1 - n_solid_regions);
        result.assign(pcInfiniteVoid);
        resultList.append(result);

        if (num)
            PK_MEMORY_free(entity);

        //////////////////**shells**//////////////////////////////////////
        PK_BODY_ask_shells(body, &num, &entity);
        char pcShell[BUFFER_SIZE];
        sprintf_s(pcShell, BUFFER_SIZE, "%d shell(s):\r\n", num);
        result.assign(pcShell);
        resultList.append(result);
        for (int i = 0; i < num; i++)
        {
            PK_SHELL_ask_type(entity[i], &shell_type);
            if (shell_type == PK_SHELL_type_acorn_c)
                n_acorn++;
            if (shell_type == PK_SHELL_type_wireframe_c)
                n_wire++;
            if (shell_type == PK_SHELL_type_wireframe_free_c)
                n_wire_free++;
            if (shell_type == PK_SHELL_type_mixed_c)
                n_mixed++;
        }
        char pcAcorn[BUFFER_SIZE];
        sprintf_s(pcAcorn, BUFFER_SIZE, "\t %d acorn, %d wireframe, %d wireframe free, %d mixed\r\n", n_acorn, n_wire, n_wire_free, n_mixed);
        result.assign(pcAcorn);
        resultList.append(result);

        if (num)
            PK_MEMORY_free(entity);

        //////////////////**faces**//////////////////////////////////////
        PK_BODY_ask_faces(body, &num, &entity);
        char pcFaces[BUFFER_SIZE];
        sprintf_s(pcFaces, BUFFER_SIZE, "%d face(s)\r\n", num);
        result.assign(pcFaces);
        resultList.append(result);
        if (num)
            PK_MEMORY_free(entity);

        PK_SURF_t surf;
        PK_CLASS_t pkclass;

        for (int i = 0; i < num; i++)
        {
            PK_FACE_ask_surf(entity[i], &surf);
            PK_ENTITY_ask_class(surf, &pkclass);
            if (pkclass == PK_CLASS_mesh)
            {
                int nfacets;
                PK_MESH_ask_n_mfacets(surf, &nfacets);
            }

            int id;
            PK_ENTITY_ask_identifier(entity[i], &id);
            std::cout << id << std::endl;
        }

        //////////////////**loops**//////////////////////////////////////
        PK_BODY_ask_loops(body, &num, &entity);
        char pcLoops[BUFFER_SIZE];
        sprintf_s(pcLoops, BUFFER_SIZE, "%d loop(s):\r\n", num);
        result.assign(pcLoops);
        resultList.append(result);
        for (int i = 0; i < num; i++)
        {
            PK_LOOP_ask_type(entity[i], &loop_types);
            if (loop_types == PK_LOOP_type_vertex_c)
                n_vertex++;
            if (loop_types == PK_LOOP_type_wire_c)
                n_wireframe_vertex++;
            if (loop_types == PK_LOOP_type_outer_c)
                n_outer++;
            if (loop_types == PK_LOOP_type_inner_c)
                n_inner++;
            if (loop_types == PK_LOOP_type_winding_c)
                n_winding++;
            if (loop_types == PK_LOOP_type_inner_sing_c)
                n_inner_sing++;
            if (loop_types == PK_LOOP_type_likely_inner_c)
                n_likely_inner++;
            if (loop_types == PK_LOOP_type_likely_outer_c)
                n_likely_outer++;
            if (loop_types == PK_LOOP_type_unclear_c || loop_types == PK_LOOP_type_error_c)
                n_unclear++;
        }

        char pcVertex[BUFFER_SIZE];
        sprintf_s(pcVertex, BUFFER_SIZE, "\t %d vertex, %d wire, %d inner, %d outer, %d winding, %d inner singularity, %d likely inner, %d likely outer, %d unclear \r\n",
            n_vertex, n_wireframe_vertex, n_inner, n_outer, n_winding, n_inner_sing,
            n_likely_inner, n_likely_outer, n_unclear);
        result.assign(pcVertex);
        resultList.append(result);

        if (num)
            PK_MEMORY_free(entity);

        //////////////////**fins**//////////////////////////////////////
        PK_BODY_ask_fins(body, &num, &entity);
        char pcFins[BUFFER_SIZE];
        sprintf_s(pcFins, BUFFER_SIZE, "%d fin(s)\r\n", num);
        result.assign(pcFins);
        resultList.append(result);

        if (num)
            PK_MEMORY_free(entity);

        //////////////////**edges**//////////////////////////////////////


        PK_BODY_ask_edges(body, &num, &entity);


        char pcEdges[BUFFER_SIZE];
        sprintf_s(pcEdges, BUFFER_SIZE, "%d edge(s):\r\n", num);
        result.assign(pcEdges);
        resultList.append(result);

        for (int i = 0; i < num; i++)
        {
            PK_EDGE_ask_type(entity[i], &edge_types);
            if (edge_types.fins_type == PK_EDGE_type_wireframe_c)
                n_wireframe++;
            if (edge_types.fins_type == PK_EDGE_type_laminar_c)
                n_laminar++;
            if (edge_types.fins_type == PK_EDGE_type_normal_c)
                n_normal++;
            if (edge_types.fins_type == PK_EDGE_type_general_c)
                n_general++;
        }

        char pcWireFrame[BUFFER_SIZE];
        sprintf_s(pcWireFrame, BUFFER_SIZE, "\t %d wireframe, %d laminar, %d normal, %d general\r\n", n_wireframe, n_laminar, n_normal, n_general);
        result.assign(pcWireFrame);
        resultList.append(result);

        if (num)
            PK_MEMORY_free(entity);

        //////////////////**vertices**//////////////////////////////////////
        PK_BODY_ask_vertices(body, &num, &entity);
        char pcVert[BUFFER_SIZE];
        if (num == 1)
            sprintf_s(pcVert, BUFFER_SIZE, "%d vertex:\r\n", num);
        else
            sprintf_s(pcVert, BUFFER_SIZE, "%d vertices:\r\n", num);
        resultList.append(pcVert);
        for (int i = 0; i < num; i++)
        {
            PK_VERTEX_ask_type(entity[i], &vertex_types);
            if (vertex_types == PK_VERTEX_type_isolated_c)
                n_isolated++;
            if (vertex_types == PK_VERTEX_type_spur_c)
                n_spur++;
            if (vertex_types == PK_VERTEX_type_wire_c)
                n_wire_vertex++;
            if (vertex_types == PK_VERTEX_type_normal_c)
                n_norm++;
        }

        char pcIsolated[BUFFER_SIZE];

        sprintf_s(pcIsolated, BUFFER_SIZE, "\t %d isolated, %d spur, %d wire, %d normal\r\n", n_isolated, n_spur, n_wire_vertex, n_norm);
        result.assign(pcIsolated);
        resultList.append(result);
        if (num)
            PK_MEMORY_free(entity);

        std::cout << resultList.c_str() << std::endl;
    }

    void displayVertices(PK_BODY_t body)
    {
        int num = 0;
        PK_ENTITY_t *entity;
        int n_isolated = 0, n_spur = 0, n_wire_vertex = 0, n_norm = 0;
        PK_VERTEX_type_t vertex_types;

        PK_BODY_ask_vertices(body, &num, &entity);
        char pcVert[BUFFER_SIZE];
        if (num == 1)
            sprintf_s(pcVert, BUFFER_SIZE, "%d vertex:\r\n", num);
        else
            sprintf_s(pcVert, BUFFER_SIZE, "%d vertices:\r\n", num);

        std::string resultList;
        std::string result;
        resultList.append(pcVert);
        for (int i = 0; i < num; i++)
        {
            PK_VERTEX_ask_type(entity[i], &vertex_types);
            if (vertex_types == PK_VERTEX_type_isolated_c)
                n_isolated++;
            if (vertex_types == PK_VERTEX_type_spur_c)
                n_spur++;
            if (vertex_types == PK_VERTEX_type_wire_c)
            {
                n_wire_vertex++;
                PK_POINT_t point;
                PK_POINT_sf_t point_sf;
                PK_VERTEX_ask_point(entity[i], &point);
                PK_POINT_ask(point, &point_sf);
                std::cout << std::to_string(point_sf.position.coord[0]) << ";" << std::to_string(point_sf.position.coord[1]) << ";" << std::to_string(point_sf.position.coord[2]) << std::endl;
            }
            if (vertex_types == PK_VERTEX_type_normal_c)
                n_norm++;
        }

        char pcIsolated[BUFFER_SIZE];

        sprintf_s(pcIsolated, BUFFER_SIZE, "\t %d isolated, %d spur, %d wire, %d normal\r\n", n_isolated, n_spur, n_wire_vertex, n_norm);
        result.assign(pcIsolated);
        resultList.append(result);
        if (num)
            PK_MEMORY_free(entity);

        std::cout << resultList << std::endl;
    }

    glm::dvec3 getFaceNormal(PK_FACE_t face)
    {
        PK_SURF_t surf;
        PK_LOGICAL_t orientation;
        PK_FACE_ask_oriented_surf(face, &surf, &orientation);
        PK_UV_t uv;
        uv.param[0] = 0.5f;
        uv.param[1] = 0.5f;
        PK_VECTOR_t p[4];
        PK_VECTOR_t normal;
        PK_SURF_eval_with_normal(surf, uv, 1, 1, PK_LOGICAL_false, p, &normal);
        PK_VECTOR1_t normalNormalised;
        PK_VECTOR_normalise(normal, &normalNormalised);

        if (orientation == PK_LOGICAL_false)
            normalNormalised = { -normalNormalised.coord[0], -normalNormalised.coord[1], -normalNormalised.coord[2] };

        return glm::dvec3(normalNormalised.coord[0], normalNormalised.coord[2], normalNormalised.coord[1]);
    }

    /*
    PK_VECTOR_t getPolygonPoint(glm::vec2 screenPos, PK_FACE_t& face)
    {
        auto x = (2.0f * screenPos.x) / _width - 1.0f;
        auto y = 1.0f - (2.0f * screenPos.y) / _height;

        auto invPersp = glm::inverse(_projectionMatrix);
        auto invView = glm::inverse(_viewMatrix);

        auto ray_clip = glm::vec4(x, y, -1.0f, 1.0f);
        auto ray_eye = invPersp * ray_clip;
        ray_eye = glm::vec4(ray_eye.x, ray_eye.y, -1.0f, 0.0f);
        auto ray_world = glm::vec3(invView * ray_eye);
        ray_world = glm::normalize(ray_world);

        //_camera->getPosition(), ray_world
        PK_VECTOR_t location;
        location.coord[0] = _camera->getPosition().x;
        location.coord[2] = _camera->getPosition().y;
        location.coord[1] = _camera->getPosition().z;
        PK_VECTOR1_t axis;
        PK_VECTOR_normalise({ ray_world.x, ray_world.z, ray_world.y }, &axis);
        PK_AXIS1_sf_t ray;
        ray.location = location;
        ray.axis = axis;
        PK_BODY_pick_topols_o_t opt;
        PK_BODY_pick_topols_o_m(opt);
        PK_BODY_pick_topols_r_t ret;
        PK_BODY_pick_topols(_bodies.size(), _bodies.data(), NULL, &ray, &opt, &ret);

        if (ret.n_faces > 0)
        {
            face = ret.faces[0].entity;
            return ret.faces[0].intersect;
        }
        else
        {
            face = -1;
            auto t = (-_camera->getPosition().y) / ray_world.y;
            auto groundIntersection = _camera->getPosition() + ray_world * t;
            return{ groundIntersection.x, groundIntersection.z, groundIntersection.y };
        }
    }
    */

    /* 
    
    */

    /*
    void initOffset()
    {
        _startPos = _currentPos;

        auto x = (2.0f * _mouseDownPos.x) / _width - 1.0f;
        auto y = 1.0f - (2.0f * _mouseDownPos.y) / _height;

        auto invPersp = glm::inverse(_projectionMatrix);
        auto invView = glm::inverse(_viewMatrix);

        auto ray_clip = glm::vec4(x, y, -1.0f, 1.0f);
        auto ray_eye = invPersp * ray_clip;
        ray_eye = glm::vec4(ray_eye.x, ray_eye.y, -1.0f, 0.0f);
        auto ray_world = glm::dvec3(invView * ray_eye);
        ray_world = glm::normalize(ray_world);

        //_camera->getPosition(), ray_world
        PK_VECTOR_t location;
        location.coord[0] = _camera->getPosition().x;
        location.coord[2] = _camera->getPosition().y;
        location.coord[1] = _camera->getPosition().z;
        PK_VECTOR1_t axis;
        axis.coord[0] = ray_world.x;
        axis.coord[2] = ray_world.y;
        axis.coord[1] = ray_world.z;
        PK_AXIS1_sf_t ray;
        ray.location = location;
        ray.axis = axis;
        PK_BODY_pick_topols_o_t opt;
        PK_BODY_pick_topols_o_m(opt);
        PK_BODY_pick_topols_r_t ret;
        PK_BODY_pick_topols(_bodies.size(), _bodies.data(), NULL, &ray, &opt, &ret);

        for (int i = 0; i < ret.n_faces; i++)
        {
            _offsetFace = ret.faces[i].entity;
            _offsetDir = getFaceNormal(_offsetFace);
            PK_FACE_ask_body(_offsetFace, &_offsetBody);

            _geometries.erase(std::remove(_geometries.begin(), _geometries.end(), _bodyGeometries[_offsetBody]), _geometries.end());
            _bodies.erase(std::remove(_bodies.begin(), _bodies.end(), _offsetBody), _bodies.end());
            _bodyGeometries.erase(_offsetBody);

            PK_BODY_t copyBody;
            PK_ENTITY_copy_o_t opt;
            PK_ENTITY_copy_o_m(opt);
            PK_ENTITY_track_r_t track;
            auto er = PK_ENTITY_copy_2(_offsetBody, &opt, &copyBody, &track);
            checkError(er);

            _tempBody = copyBody;
            _tempGeometry = createGeometry(copyBody);
            _geometries.push_back(_tempGeometry);

            lastT2 = 0.0f;
        }
    }
    */

    /*
    void offsetFace()
    {
        auto worldToScreen = [&](glm::vec3 worldPos)
        {
            auto vp = _projectionMatrix * _viewMatrix;
            auto vw = _width * 0.5f;
            auto vh = _height * 0.5f;
            auto v = glm::vec2(vw, vh);
            auto pos = glm::vec4(worldPos, 1.0);
            pos = vp * pos;
            pos = pos / pos.w;
            return glm::vec2(pos.x, -pos.y) * v + v;
        };

        auto screenToViewZNear = [&](glm::vec2 mousePos)
        {
            auto zNear = _zNear;
            auto aspect = _aspect;
            auto fov = _fov;

            auto tg = glm::tan(fov * 0.5f) * zNear;

            auto h = _height;
            auto w = _width;

            auto hh = h * 0.5f;
            auto hw = w * 0.5f;

            auto ys = mousePos.y - hh;
            auto yp = ys / hh;
            auto y = -(yp * tg);

            auto xs = mousePos.x - hw;
            auto xp = xs / hw;
            auto x = xp * tg * aspect;

            return glm::vec3(x, y, -zNear);
        };

        auto dir = glm::vec3(_offsetDir.coord[0], _offsetDir.coord[2], _offsetDir.coord[1]);

        auto screenObjectPos = worldToScreen(_startPos);
        auto screenObjectDir = glm::normalize(worldToScreen(_startPos + dir) - screenObjectPos);
        auto mouseStartToEnd = glm::vec2(_lastMousePos.x, _lastMousePos.y) - screenObjectPos;
        auto projMouseIntoScreenObjectDir = glm::dot(mouseStartToEnd, screenObjectDir);
        auto screenObjectEndPos = screenObjectPos + screenObjectDir * projMouseIntoScreenObjectDir;// -glm::dot(_mouseDownPos - screenObjectPos, screenObjectDir));
        auto viewObjectEndPos = screenToViewZNear(screenObjectEndPos);

        auto worldToView = [&](const glm::vec3 vec)
        {
            auto vec4 = glm::vec4(vec.x, vec.y, vec.z, 1.0f);
            vec4 = _viewMatrix * vec4;
            return glm::vec3(vec4.x, vec4.y, vec4.z);
        };

        auto viewObjectStartPos = worldToView(_startPos);
        auto viewObjectStartDirPos = worldToView(_startPos + dir);

        glm::vec3 p1, p2;
        float t1, t2;
        if (lineLineIntersect(glm::vec3(), viewObjectEndPos, viewObjectStartPos, viewObjectStartDirPos, &p1, &p2, &t1, &t2))
        {
            auto localWorld = _startPos + dir * t2;
            _currentPos = localWorld;
            double dist = t2 - lastT2;
            lastT2 = t2;

            PK_BODY_t copyBody;
            PK_ENTITY_copy_o_t opt;
            PK_ENTITY_copy_o_m(opt);
            opt.want_tracking = PK_LOGICAL_true;
            PK_ENTITY_track_r_t track;
            auto er = PK_ENTITY_copy_2(_offsetBody, &opt, &copyBody, &track);
            checkError(er);

            if (er)
                return;

            PK_FACE_t copyFace;

            for (auto i = 0; i < track.n_track_records; i++)
            {
                auto r = track.track_records[i];
                for (auto j = 0; j < r.n_original_entities; j++)
                {
                    auto entity = r.original_entities[j];
                    if (entity == _offsetFace)
                        copyFace = r.product_entities[j];
                }
            }

            PK_TOPOL_track_r_t track_r_t;
            PK_TOPOL_local_r_t local_r_t;
            PK_FACE_change_t offset;
            offset.op_type = PK_FACE_change_type_offset_c;
            offset.op_param.offset.distance = (double)t2;
            PK_FACE_change_offset_o_t offset_opt;
            PK_FACE_change_offset_o_m(offset_opt);
            offset_opt.offset_step = PK_offset_step_all_c;
            offset.op_opts.offset = &offset_opt;
            PK_FACE_change_o_t face_change_opt;
            PK_FACE_change_o_m(face_change_opt);
            face_change_opt.check_fa_fa = PK_check_fa_fa_yes_c;
            face_change_opt.repair_fa_fa = PK_repair_fa_fa_yes_c;
            int mapping = 0;
            er = PK_FACE_change(1, &copyFace, &mapping, 1, &offset, 1.0e-05, &face_change_opt, &track_r_t, &local_r_t);
            checkError(er);

            if (!er)
            {
                PK_ENTITY_delete(1, &_tempBody);
                updateGeometry(copyBody, _tempGeometry);
                _tempBody = copyBody;
            }
        }
    }
    */

    /*
    void endOffset()
    {
        _bodies.push_back(_tempBody);
        _bodyGeometries[_tempBody] = _tempGeometry;
        _tempGeometry = nullptr;
        PK_ENTITY_delete(1, &_offsetBody);
    }
    */

    void startSession()
    {
        BOOL ok = TRUE;

        PK_SESSION_frustrum_t fru;
        PK_SESSION_frustrum_o_m(fru);

        fru.fstart = StartFrustrum;
        fru.fabort = AbortFrustrum;
        fru.fstop = StopFrustrum;
        fru.fmallo = GetMemory;
        fru.fmfree = ReturnMemory;
        fru.ffoprd = OpenReadFrustrumFile;
        fru.ffopwr = OpenWriteFrustrumFile;
        fru.ffclos = CloseFrustrumFile;
        fru.ffread = ReadFromFrustrumFile;
        fru.ffwrit = WriteToFrustrumFile;

        if (PK_SESSION_register_frustrum(&fru) != PK_ERROR_no_errors)
            std::cout << ":(" << std::endl;

        PK_SESSION_start_o_t options;
        PK_SESSION_start_o_m(options);

        PK_SESSION_start(&options);

        PK_SESSION_set_facet_geometry(PK_facet_geometry_all_c);
    }

    void stopSession()
    {
        PK_SESSION_stop();
    }

public:

    parasolid()
    {
        startSession();
    }

    ~parasolid()
    {
        stopSession();
    }

    PK_BODY_t loadX_TFile(std::string fileName)
    {
        PK_PART_receive_o_t receive_opt;
        PK_PART_receive_o_m(receive_opt);
        receive_opt.transmit_format = PK_transmit_format_text_c;
        int n_parts;
        PK_PART_t* parts;
        const char * cString = fileName.c_str();
        auto er = PK_PART_receive(cString, &receive_opt, &n_parts, &parts);
        checkError(er);

        PK_BODY_t body = (PK_BODY_t)parts[0];
        displayModelStructure(body);
        return body;
    }

    void createGeometry(PK_BODY_t body, std::vector<vertex>& vertices, std::vector<uint>& indices)
    {
        findGeometryData(body, vertices, indices);
    }

    void checkError(int error)
    {
        if (error != PK_ERROR_no_errors)
        {
            PK_LOGICAL_t was_error = PK_LOGICAL_false;
            PK_ERROR_sf_t error_sf;

            // Ask the last error returned in the current thread
            PK_ERROR_ask_last(&was_error, &error_sf);

            std::cout << "error: " << error_sf.code_token << std::endl;
        }
    }

    bool getFace(PK_BODY_t body, ray ray, collision &collision)
    {
        //_camera->getPosition(), ray_world
        PK_VECTOR_t location;
        location.coord[0] = ray.origin.x;
        location.coord[2] = ray.origin.y;
        location.coord[1] = ray.origin.z;
        
        PK_VECTOR1_t axis;
        axis.coord[0] = ray.direction.x;
        axis.coord[2] = ray.direction.y;
        axis.coord[1] = ray.direction.z;
        
        PK_AXIS1_sf_t parasolidRay;
        parasolidRay.location = location;
        parasolidRay.axis = axis;

        PK_BODY_pick_topols_o_t opt;
        PK_BODY_pick_topols_o_m(opt);
        opt.ignore_back_faces = PK_LOGICAL_false;
        opt.max_faces = 1;
        opt.max_edges = 0; 
        opt.max_vertices = 0;
        
        PK_BODY_pick_topols_r_t ret;
        auto e = PK_BODY_pick_topols(1, &body, NULL, &parasolidRay, &opt, &ret);
        checkError(e);

        if (ret.n_faces > 0)
        {
            auto f = ret.faces[0];
            PK_ENTITY_ask_identifier(f.entity, &collision.parasolidId);
            collision.worldPos = glm::dvec3(f.intersect.coord[0], f.intersect.coord[2], f.intersect.coord[1]);
            collision.worldNormal = getFaceNormal(f.entity);
            return true;
        }

        return false;

        /*for (int i = 0; i < ret.n_faces; i++)
        {
            _offsetFace = ret.faces[i].entity;
            _offsetDir = getFaceNormal(_offsetFace);
            PK_FACE_ask_body(_offsetFace, &_offsetBody);

            _geometries.erase(std::remove(_geometries.begin(), _geometries.end(), _bodyGeometries[_offsetBody]), _geometries.end());
            _bodies.erase(std::remove(_bodies.begin(), _bodies.end(), _offsetBody), _bodies.end());
            _bodyGeometries.erase(_offsetBody);

            PK_BODY_t copyBody;
            PK_ENTITY_copy_o_t opt;
            PK_ENTITY_copy_o_m(opt);
            PK_ENTITY_track_r_t track;
            auto er = PK_ENTITY_copy_2(_offsetBody, &opt, &copyBody, &track);
            checkError(er);

            _tempBody = copyBody;
            _tempGeometry = createGeometry(copyBody);
            _geometries.push_back(_tempGeometry);

            lastT2 = 0.0f;
        }*/


    }
};